// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0

package sqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AccessType string

const (
	AccessTypeFree AccessType = "free"
	AccessTypePaid AccessType = "paid"
)

func (e *AccessType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccessType(s)
	case string:
		*e = AccessType(s)
	default:
		return fmt.Errorf("unsupported scan type for AccessType: %T", src)
	}
	return nil
}

type NullAccessType struct {
	AccessType AccessType `json:"access_type"`
	Valid      bool       `json:"valid"` // Valid is true if AccessType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccessType) Scan(value interface{}) error {
	if value == nil {
		ns.AccessType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccessType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccessType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccessType), nil
}

type EventType string

const (
	EventTypeLive   EventType = "live"
	EventTypeOnline EventType = "online"
)

func (e *EventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventType(s)
	case string:
		*e = EventType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventType: %T", src)
	}
	return nil
}

type NullEventType struct {
	EventType EventType `json:"event_type"`
	Valid     bool      `json:"valid"` // Valid is true if EventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventType) Scan(value interface{}) error {
	if value == nil {
		ns.EventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventType), nil
}

type RecurrenceType string

const (
	RecurrenceTypeSingle   RecurrenceType = "single"
	RecurrenceTypeDaily    RecurrenceType = "daily"
	RecurrenceTypeWeekly   RecurrenceType = "weekly"
	RecurrenceTypeBiweekly RecurrenceType = "biweekly"
)

func (e *RecurrenceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RecurrenceType(s)
	case string:
		*e = RecurrenceType(s)
	default:
		return fmt.Errorf("unsupported scan type for RecurrenceType: %T", src)
	}
	return nil
}

type NullRecurrenceType struct {
	RecurrenceType RecurrenceType `json:"recurrence_type"`
	Valid          bool           `json:"valid"` // Valid is true if RecurrenceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRecurrenceType) Scan(value interface{}) error {
	if value == nil {
		ns.RecurrenceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RecurrenceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRecurrenceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RecurrenceType), nil
}

type StockType string

const (
	StockTypeLimited   StockType = "limited"
	StockTypeUnlimited StockType = "unlimited"
)

func (e *StockType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StockType(s)
	case string:
		*e = StockType(s)
	default:
		return fmt.Errorf("unsupported scan type for StockType: %T", src)
	}
	return nil
}

type NullStockType struct {
	StockType StockType `json:"stock_type"`
	Valid     bool      `json:"valid"` // Valid is true if StockType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStockType) Scan(value interface{}) error {
	if value == nil {
		ns.StockType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StockType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStockType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StockType), nil
}

type TicketType string

const (
	TicketTypeSingle TicketType = "single"
	TicketTypeGroup  TicketType = "group"
)

func (e *TicketType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TicketType(s)
	case string:
		*e = TicketType(s)
	default:
		return fmt.Errorf("unsupported scan type for TicketType: %T", src)
	}
	return nil
}

type NullTicketType struct {
	TicketType TicketType `json:"ticket_type"`
	Valid      bool       `json:"valid"` // Valid is true if TicketType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTicketType) Scan(value interface{}) error {
	if value == nil {
		ns.TicketType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TicketType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTicketType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TicketType), nil
}

type Event struct {
	ID            uuid.UUID      `json:"id"`
	UserID        uuid.UUID      `json:"user_id"`
	Type          EventType      `json:"type"`
	Name          string         `json:"name"`
	Description   string         `json:"description"`
	UrlSlug       pgtype.Text    `json:"url_slug"`
	Category      string         `json:"category"`
	Recurrence    RecurrenceType `json:"recurrence"`
	Timezone      string         `json:"timezone"`
	StartDate     pgtype.Date    `json:"start_date"`
	EndDate       pgtype.Date    `json:"end_date"`
	StartTime     pgtype.Time    `json:"start_time"`
	EndTime       pgtype.Time    `json:"end_time"`
	SocialDetails []byte         `json:"social_details"`
	Location      interface{}    `json:"location"`
	ImageID       pgtype.UUID    `json:"image_id"`
}

type Image struct {
	ID      uuid.UUID `json:"id"`
	EventID uuid.UUID `json:"event_id"`
	Url     string    `json:"url"`
}

type Ticket struct {
	ID            uuid.UUID     `json:"id"`
	EventID       uuid.UUID     `json:"event_id"`
	Invite        pgtype.Bool   `json:"invite"`
	Type          TicketType    `json:"type"`
	AccessType    AccessType    `json:"access_type"`
	Name          string        `json:"name"`
	StockType     NullStockType `json:"stock_type"`
	StockCount    pgtype.Int4   `json:"stock_count"`
	PurchaseLimit pgtype.Int4   `json:"purchase_limit"`
	GroupSize     pgtype.Int4   `json:"group_size"`
	Description   string        `json:"description"`
	Price         pgtype.Int4   `json:"price"`
}

type User struct {
	ID           uuid.UUID          `json:"id"`
	Email        string             `json:"email"`
	Password     string             `json:"password"`
	Verified     pgtype.Bool        `json:"verified"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
}
